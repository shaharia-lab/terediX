package scanner

import (
	"context"
	"teredix/pkg/resource"
	"testing"

	"github.com/google/go-github/v50/github"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

// GitHubClientMock is an autogenerated mock type for the GitHubClient type
type GitHubClientMock struct {
	mock.Mock
}

// ListRepositories provides a mock function with given fields: ctx, user
func (_m *GitHubClientMock) ListRepositories(ctx context.Context, user string) ([]*github.Repository, error) {
	ret := _m.Called(ctx, user)

	var r0 []*github.Repository
	if rf, ok := ret.Get(0).(func(context.Context, string) []*github.Repository); ok {
		r0 = rf(ctx, user)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*github.Repository)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

func TestGitHubRepositoryScanner_Scan(t *testing.T) {
	// Define mock data
	mockRepos := []*github.Repository{
		{
			ID:              github.Int64(1),
			Name:            github.String("repo1"),
			FullName:        github.String("user/repo1"),
			Language:        github.String("Go"),
			StargazersCount: github.Int(10),
		},
		{
			ID:              github.Int64(2),
			Name:            github.String("repo2"),
			FullName:        github.String("user/repo2"),
			Language:        github.String("Java"),
			StargazersCount: github.Int(20),
		},
	}

	// Create mock client and inject into scanner
	mockClient := new(GitHubClientMock)
	mockClient.On("ListRepositories", mock.Anything, mock.Anything).Return(mockRepos, nil)
	scanner := NewGitHubRepositoryScanner(mockClient, "user")

	// Call Scan method and verify the result
	resources := scanner.Scan()
	require.Len(t, resources, 2)

	expectedResource1 := resource.Resource{
		Kind:       "GitHubRepository",
		UUID:       "1",
		Name:       "repo1",
		ExternalID: "user/repo1",
		MetaData: []resource.MetaData{
			{
				Key:   "Language",
				Value: "Go",
			},
			{
				Key:   "Stars",
				Value: "10",
			},
		},
	}

	expectedResource2 := resource.Resource{
		Kind:       "GitHubRepository",
		UUID:       "2",
		Name:       "repo2",
		ExternalID: "user/repo2",
		MetaData: []resource.MetaData{
			{
				Key:   "Language",
				Value: "Java",
			},
			{
				Key:   "Stars",
				Value: "20",
			},
		},
	}

	assert.Contains(t, resources, expectedResource1)
	assert.Contains(t, resources, expectedResource2)
	mockClient.AssertExpectations(t)
}

func TestGitHubRepositoryScanner_Scan2(t *testing.T) {
	testCases := []struct {
		name           string
		user           string
		ghRepositories []*github.Repository
		want           []resource.Resource
	}{
		{
			name: "returns resources",
			user: "testuser",
			ghRepositories: []*github.Repository{
				{
					ID:              github.Int64(123),
					Name:            github.String("testrepo"),
					FullName:        github.String("testuser/testrepo"),
					Language:        github.String("Go"),
					StargazersCount: github.Int(42),
				},
			},
			want: []resource.Resource{
				{
					Kind:       "GitHubRepository",
					UUID:       "123",
					Name:       "testrepo",
					ExternalID: "testuser/testrepo",
					MetaData: []resource.MetaData{
						{Key: "Language", Value: "Go"},
						{Key: "Stars", Value: "42"},
					},
				},
			},
		},
		{
			name:           "returns empty resource list on error",
			user:           "testuser",
			ghRepositories: []*github.Repository{},
			want:           []resource.Resource{},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			mockClient := new(GitHubClientMock)
			mockClient.On("ListRepositories", mock.Anything, mock.Anything).Return(tc.ghRepositories, nil)

			s := NewGitHubRepositoryScanner(mockClient, tc.user)
			got := s.Scan()

			assert.Equal(t, len(tc.ghRepositories), len(got))
		})
	}
}
