package util

import (
	"context"
	"errors"
	"reflect"

	"github.com/aws/aws-sdk-go-v2/service/resourcegroupstaggingapi/types"
	"github.com/aws/aws-sdk-go/aws"

	"github.com/aws/aws-sdk-go-v2/service/resourcegroupstaggingapi"
	"github.com/stretchr/testify/mock"

	"github.com/stretchr/testify/assert"

	"testing"
)

func TestGenerateUUID(t *testing.T) {
	// Generate a UUID
	uuid := GenerateUUID()

	// Verify that the UUID is in the correct format
	if len(uuid) != 36 {
		t.Errorf("UUID is not in the correct format: %s", uuid)
	}
}

func TestRetryWithExponentialBackoff(t *testing.T) {
	testCases := []struct {
		name        string
		callback    func() error
		expectError bool
	}{
		{
			name: "function returns error",
			callback: func() error {
				return errors.New("error")
			},
			expectError: true,
		},
		{
			name: "function returns no error",
			callback: func() error {
				return nil
			},
			expectError: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Define the maximum number of retries and the backoff intervals
			maxRetries := 1
			initialBackoff := 1

			// Call the function with retry and check the result
			err := RetryWithExponentialBackoff(tc.callback, maxRetries, initialBackoff)

			if tc.expectError {
				assert.Error(t, err)
				// Check the error message
				expectedErrorMessage := "maximum number of retries exceeded: error"
				if err.Error() != expectedErrorMessage {
					t.Errorf("unexpected error message: got %v, want %v", err.Error(), expectedErrorMessage)
				}
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

// ResourceTaggingServiceClient is an autogenerated mock type for the ResourceTaggingServiceClient type
type ResourceTaggingServiceClientMock struct {
	mock.Mock
}

// GetResources provides a mock function with given fields: _a0, _a1, _a2
func (_m *ResourceTaggingServiceClientMock) GetResources(_a0 context.Context, _a1 *resourcegroupstaggingapi.GetResourcesInput, _a2 ...func(*resourcegroupstaggingapi.Options)) (*resourcegroupstaggingapi.GetResourcesOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *resourcegroupstaggingapi.GetResourcesOutput
	if rf, ok := ret.Get(0).(func(context.Context, *resourcegroupstaggingapi.GetResourcesInput, ...func(*resourcegroupstaggingapi.Options)) *resourcegroupstaggingapi.GetResourcesOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*resourcegroupstaggingapi.GetResourcesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *resourcegroupstaggingapi.GetResourcesInput, ...func(*resourcegroupstaggingapi.Options)) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

func TestGetAWSResourceTagByARN(t *testing.T) {
	ctx := context.Background()

	// Create a mock client
	mockSvc := new(ResourceTaggingServiceClientMock)

	expectedOutput := &resourcegroupstaggingapi.GetResourcesOutput{
		ResourceTagMappingList: []types.ResourceTagMapping{
			{
				Tags: []types.Tag{
					{
						Key:   aws.String("Environment"),
						Value: aws.String("prod"),
					},
					{
						Key:   aws.String("Owner"),
						Value: aws.String("john@example.com"),
					},
				},
			},
		},
	}

	mockSvc.On("GetResources", mock.Anything, mock.Anything, mock.Anything).Return(expectedOutput, nil)
	// Call the function with the mock client
	tags, err := GetAWSResourceTagByARN(ctx, mockSvc, "arn:aws:s3:::my-bucket")
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	// Check that the returned tags match the expected tags
	expectedTags := map[string]string{
		"Environment": "prod",
		"Owner":       "john@example.com",
	}
	if !reflect.DeepEqual(tags, expectedTags) {
		t.Errorf("Unexpected tags: got %v, expected %v", tags, expectedTags)
	}
}

func TestIsExist(t *testing.T) {
	testCases := []struct {
		name  string
		what  interface{}
		in    interface{}
		want  bool
		panic bool
	}{
		{
			name: "int in int slice",
			what: 1,
			in:   []int{1, 2, 3},
			want: true,
		},
		{
			name: "int not in int slice",
			what: 4,
			in:   []int{1, 2, 3},
			want: false,
		},
		{
			name: "float in float slice",
			what: 1.234,
			in:   []float64{1.234, 2.345, 3.456},
			want: true,
		},
		{
			name: "string in string slice",
			what: "hello",
			in:   []string{"hello", "world", "foo", "bar"},
			want: true,
		},
		{
			name: "bool in bool slice",
			what: true,
			in:   []bool{true, false},
			want: true,
		},
		{
			name:  "panic with non-slice",
			what:  "foo",
			in:    "bar",
			panic: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					if !tc.panic {
						t.Errorf("unexpected panic: %v", r)
					}
				} else if tc.panic {
					t.Errorf("expected panic but did not occur")
				}
			}()

			got := IsExist(tc.what, tc.in)

			if got != tc.want {
				t.Errorf("IsExist(%v, %v) = %v; want %v", tc.what, tc.in, got, tc.want)
			}
		})
	}
}
