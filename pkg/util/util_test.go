package util

import (
	"context"
	"errors"
	"reflect"

	"github.com/aws/aws-sdk-go-v2/service/resourcegroupstaggingapi/types"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/shaharia-lab/teredix/pkg/resource"

	"github.com/aws/aws-sdk-go-v2/service/resourcegroupstaggingapi"
	"github.com/stretchr/testify/mock"

	"github.com/stretchr/testify/assert"

	"testing"
)

func TestGenerateUUID(t *testing.T) {
	// Generate a UUID
	uuid := GenerateUUID()

	// Verify that the UUID is in the correct format
	if len(uuid) != 36 {
		t.Errorf("UUID is not in the correct format: %s", uuid)
	}
}

func TestRetryWithExponentialBackoff(t *testing.T) {
	testCases := []struct {
		name        string
		callback    func() error
		expectError bool
	}{
		{
			name: "function returns error",
			callback: func() error {
				return errors.New("error")
			},
			expectError: true,
		},
		{
			name: "function returns no error",
			callback: func() error {
				return nil
			},
			expectError: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Define the maximum number of retries and the backoff intervals
			maxRetries := 1
			initialBackoff := 1

			// Call the function with retry and check the result
			err := RetryWithExponentialBackoff(tc.callback, maxRetries, initialBackoff)

			if tc.expectError {
				assert.Error(t, err)
				// Check the error message
				expectedErrorMessage := "maximum number of retries exceeded: error"
				if err.Error() != expectedErrorMessage {
					t.Errorf("unexpected error message: got %v, want %v", err.Error(), expectedErrorMessage)
				}
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

// ResourceTaggingServiceClient is an autogenerated mock type for the ResourceTaggingServiceClient type
type ResourceTaggingServiceClientMock struct {
	mock.Mock
}

// GetResources provides a mock function with given fields: _a0, _a1, _a2
func (_m *ResourceTaggingServiceClientMock) GetResources(_a0 context.Context, _a1 *resourcegroupstaggingapi.GetResourcesInput, _a2 ...func(*resourcegroupstaggingapi.Options)) (*resourcegroupstaggingapi.GetResourcesOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *resourcegroupstaggingapi.GetResourcesOutput
	if rf, ok := ret.Get(0).(func(context.Context, *resourcegroupstaggingapi.GetResourcesInput, ...func(*resourcegroupstaggingapi.Options)) *resourcegroupstaggingapi.GetResourcesOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*resourcegroupstaggingapi.GetResourcesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *resourcegroupstaggingapi.GetResourcesInput, ...func(*resourcegroupstaggingapi.Options)) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

func TestGetAWSResourceTagByARN(t *testing.T) {
	ctx := context.Background()

	// Create a mock client
	mockSvc := new(ResourceTaggingServiceClientMock)

	expectedOutput := &resourcegroupstaggingapi.GetResourcesOutput{
		ResourceTagMappingList: []types.ResourceTagMapping{
			{
				Tags: []types.Tag{
					{
						Key:   aws.String("Environment"),
						Value: aws.String("prod"),
					},
					{
						Key:   aws.String("Owner"),
						Value: aws.String("john@example.com"),
					},
				},
			},
		},
	}

	mockSvc.On("GetResources", mock.Anything, mock.Anything, mock.Anything).Return(expectedOutput, nil)
	// Call the function with the mock client
	tags, err := GetAWSResourceTagByARN(ctx, mockSvc, "arn:aws:s3:::my-bucket")
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	// Check that the returned tags match the expected tags
	expectedTags := map[string]string{
		"Environment": "prod",
		"Owner":       "john@example.com",
	}
	if !reflect.DeepEqual(tags, expectedTags) {
		t.Errorf("Unexpected tags: got %v, expected %v", tags, expectedTags)
	}
}

func TestIsFieldExistsInConfig(t *testing.T) {
	tests := []struct {
		name   string
		value  string
		fields []string
		want   bool
	}{
		{
			name:   "field exists",
			value:  "color",
			fields: []string{"color", "size", "weight"},
			want:   true,
		},
		{
			name:   "field does not exist",
			value:  "height",
			fields: []string{"color", "size", "weight"},
			want:   false,
		},
		{
			name:   "empty fields",
			value:  "color",
			fields: []string{},
			want:   false,
		},
		{
			name:   "empty value",
			value:  "",
			fields: []string{"color", "size", "weight"},
			want:   false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := IsFieldExistsInConfig(tt.value, tt.fields); got != tt.want {
				t.Errorf("IsFieldExistsInConfig(%v, %v) = %v; want %v", tt.value, tt.fields, got, tt.want)
			}
		})
	}
}

func TestCheckKeysInMetaData(t *testing.T) {
	tests := []struct {
		name            string
		resource        resource.Resource
		keys            []string
		expectedExists  bool
		expectedMissing []string
	}{
		{
			name: "all keys present",
			resource: resource.Resource{
				MetaData: []resource.MetaData{
					{Key: "key1", Value: "value1"},
					{Key: "key2", Value: "value2"},
				},
			},
			keys:            []string{"key1", "key2"},
			expectedExists:  true,
			expectedMissing: []string{},
		},
		{
			name: "some keys missing",
			resource: resource.Resource{
				MetaData: []resource.MetaData{
					{Key: "key1", Value: "value1"},
				},
			},
			keys:            []string{"key1", "key2"},
			expectedExists:  false,
			expectedMissing: []string{"key2"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			exists, missingKeys := CheckKeysInMetaData(tt.resource, tt.keys)

			if exists != tt.expectedExists {
				t.Errorf("expected existence: %v, got: %v", tt.expectedExists, exists)
			}

			if !slicesEqual(missingKeys, tt.expectedMissing) {
				t.Errorf("expected missing keys: %v, got: %v", tt.expectedMissing, missingKeys)
			}
		})
	}
}

// slicesEqual checks if two slices have the same elements, order matters.
func slicesEqual(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}
